# V1 - works

.PHONY: install
install: ## Install a package (by passing "package" argument as part of the command)
	@if [ "$$package" != "" ]; then \
		$(call log-step,[Step 1/5] Build the development image (if needed)) \
		$(call log-step,[Step 2/5] Create and start a container for installing dependencies) \
		$(call log-step,[Step 3/5] Install $$package package in the persistent storage (volume)) \
		$(call log-step,[Step 4/5] Update package.json and yarn.lock) \
		$(call log-step,[Step 5/5] Remove the container) \
		docker-compose run --name playground-installing --rm app add $$package; \
		$(call log-success,Done) \
	else \
		echo "You did not enter the package name, please try again"; \
	fi;

--------------------------------------------------------------------------------

# V2 - better

.PHONY: install
install: ## Install a package and any packages that it depends on
	@read -p "Enter package name: " package; \
	if [ "$$package" != "" ]; then \
		$(call log-step,[Step 1/5] Build the development image (if needed)) \
		$(call log-step,[Step 2/5] Create and start a container for installing dependencies) \
		$(call log-step,[Step 3/5] Install $$package package in the persistent storage (volume)) \
		$(call log-step,[Step 4/5] Update package.json and yarn.lock) \
		$(call log-step,[Step 5/5] Remove the container) \
		docker-compose run --name playground-installing --rm app add $$package; \
		$(call log-success,Done) \
	else \
		echo "You did not enter the package name, please try again"; \
	fi;

--------------------------------------------------------------------------------

# V3 - does not work

define script-install
	$(call log-step,[Step 1/5] Build the development image (if needed)) \
	$(call log-step,[Step 2/5] Create and start a container for installing dependencies) \
	$(call log-step,[Step 3/5] Install $(1) package in the persistent storage (volume)) \
	$(call log-step,[Step 4/5] Update package.json and yarn.lock) \
	$(call log-step,[Step 5/5] Remove the container) \
	docker-compose run --name playground-installing --rm app add $(1) \
	$(call log-success,Done)
endef

.PHONY: install
install: ## Install a package (by passing "package" argument as part of the command)
	@if [ "$$package" != "" ]; then \
		$(call script-install,$$package) \
	else \
		read -p "Enter package name: " package; \
		if [ "$$package" != "" ]; then \
			$(call script-install,$$package) \
		else \
			echo "You did not enter the package name, please try again"; \
		fi; \
	fi;

--------------------------------------------------------------------------------

# Not working

THIS_FILE := $(lastword $(MAKEFILE_LIST))

.PHONY: version
version: ## Set the next release version
	@$(call log-start,Setting the next release version...)
	@printf "The current version is $(call txt-bold,v${RELEASE_VERSION}) (released on ${RELEASE_DATE})\n"
	@$(newline)
	@printf "$(call txt-underline,Warning): You must reset the development environment built with the configuration of v${RELEASE_VERSION} before tagging a new release version\n"
	@$(newline)
	@read -p "Reset the development environment? " confirmation; \
	case "$$confirmation" in \
		[yY] | [yY][eE][sS]) \
			@$(MAKE) -f $(THIS_FILE) reset \
			read -p "Enter a version number: " VERSION; \
			if [ "$$VERSION" != "" ]; then \
				printf "The next release will be $(call txt-bold,v$$VERSION) on ${CURRENT_DATE} (today)\n"; \
				$(call set-env,RELEASE_DATE,${CURRENT_DATE},${CONFIG_ENV}); \
				$(call set-env,RELEASE_VERSION,$$VERSION,${CONFIG_ENV}); \
				rm ${CONFIG_ENV}.${EXT_BACKUP}; \
				$(call log-success,Done) \
			else \
				echo "You did not enter the value, please try again"; \
				echo "Skipped"; \
			fi; \
		;; \
		[nN] | [nN][oO]) \
			echo "Skipped"; \
		;; \
		*) \
			echo "Skipped, please enter y/yes or n/no"; \
		;; \
	esac

--------------------------------------------------------------------------------

# docker-compose.override.yml

  githooks:
    build:
      args:
        BUSYBOX_VERSION: ${IMAGE_BASE_BUSYBOX}
      context: .
      dockerfile: Dockerfile.githooks
      target: githooks
    container_name: "${IMAGE_REPO}-githooks"
    image: "${ENV_LOCAL}/${IMAGE_REPO}:githooks"
    volumes:
      - type: bind
        source: ./.git/hooks
        target: /tmp/.git/hooks
      - type: bind
        source: ./hooks
        target: /tmp/hooks

--------------------------------------------------------------------------------

# Makefile

docker image rm ${ENV_LOCAL}/${IMAGE_REPO}:githooks; \

--------------------------------------------------------------------------------

# package.json

"precommit": "lint-staged",

"lint-staged": {
	"linters": {
		"src/**/*.{js,jsx}": [
			"node scripts/test.js --config jest.config.json --coverage --no-cache --silent",
			"git add"
		]
	}
},

--------------------------------------------------------------------------------

# hooks/pre-commit

#!/bin/sh

# Husky 0.14.3
# Custom configuration v3

has_hook_script () {
  [ -f package.json ] && cat package.json | grep -q "\"$1\"[[:space:]]*:"
}

cd "."

# Check if precommit script is defined, skip if not
has_hook_script precommit || exit 0

# Add common path where Node can be found
# Brew standard installation path /usr/local/bin
# Node standard installation path /usr/local
export PATH="$PATH:/usr/local/bin:/usr/local"

# Export Git hook params
export GIT_PARAMS="$*"

# Run pre-commit script within a container
echo "Husky : docker container run --rm local/playground:git precommit"
echo

docker container run --rm local/playground:git precommit || {
  echo
  echo "Husky : pre-commit hook failed (add --no-verify to bypass)"
  exit 1
}

--------------------------------------------------------------------------------

txt-subheadline = printf "\e[${ANSI_COLOR_CYAN};49;1m$(1)\e[0m \n"

# Special characters
define line
	echo ""
	echo "--------------------------------------------------------------------------------"
	echo ""
endef

.PHONY: system
system: ## Display system-wide information
	@$(call log-start,Listing system-wide information...)
	@$(newline)
	@$(call txt-subheadline,Git)
	@git --version
	@$(line)
	@$(call txt-subheadline,Bash)
	@bash --version
	@$(line)
	@$(call txt-subheadline,Make)
	@make --version
	@$(line)
	@$(call txt-subheadline,Docker)
	@docker --version
	@$(line)
	@docker-compose --version
	@$(line)
	@$(call txt-subheadline,Node.js)
	@node --version
	@$(line)
	@$(call txt-subheadline,npm)
	@npm --version
	@$(line)
	@$(call txt-subheadline,Yarn)
	@yarn --version
	@$(line)

--------------------------------------------------------------------------------

txt-done = printf "\e[${ANSI_COLOR_GREEN}mDone\e[0m\n"

txt-hint = $(call log-underline,Hint)

--------------------------------------------------------------------------------

# LCOV hint
define hint-coverage
	printf "Skipped, you can view the reports later by running $(call log-bold,report) command.\n"; \
	$(txt-done)
endef

--------------------------------------------------------------------------------

.PHONY: install
install: ## Install a package and any packages that it depends on **
	@read -p "Enter package name: " PACKAGE; \
	if [ "$$PACKAGE" != "" ]; then \
		$(newline); \
		$(call log-start,Installing npm package...); \
		$(call log-step,[Step 1/5] Build the development image (if needed)); \
		$(call log-step,[Step 2/5] Create and start a container for installing dependencies); \
		$(call log-step,[Step 3/5] Install $$PACKAGE package in the persistent storage (volume)); \
		$(call log-step,[Step 4/5] Update ${CONFIG_NPM} and ${CONFIG_PACKAGE}); \
		$(call log-step,[Step 5/5] Remove the container); \
		docker-compose run --rm ${SERVICE_APP} add $$PACKAGE; \
		$(call helper-package,$$PACKAGE,install); \
		$(txt-done); \
	else \
		echo "Skipped, you did not enter the package name, please try again."; \
	fi;

--------------------------------------------------------------------------------

.PHONY: uninstall
uninstall: ## Uninstall a package **
	@if [[ `git diff ${CONFIG_NPM}` || `git diff ${CONFIG_PACKAGE}` ]]; then \
		$(call log-danger,Unable to uninstall the package!); \
		printf "$(call log-bold,${CONFIG_NPM}) and/or $(call log-bold,${CONFIG_PACKAGE}) have been modified.\n\n"; \
		read -p "Would you like to see the changes? " CONFIRMATION; \
		case "$$CONFIRMATION" in \
			[yY] | [yY][eE][sS]) \
				$(newline); \
				$(txt-result); \
				$(txt-diff); \
				git diff ${CONFIG_NPM}; \
				git diff ${CONFIG_PACKAGE}; \
				$(newline); \
				$(txt-status); \
				git status ${CONFIG_NPM} ${CONFIG_PACKAGE}; \
			;; \
		esac; \
		$(newline); \
		$(call log-sum,Summary); \
		echo "Please commit the changes before uninstalling the package."; \
		$(txt-skipped); \
	else \
		read -p "Enter package name: " PACKAGE; \
		if [ "$$PACKAGE" != "" ]; then \
			$(newline); \
			$(call log-start,Uninstalling npm package...); \
			$(call log-step,[Step 1/5] Build the development image (if needed)); \
			$(call log-step,[Step 2/5] Create and start a container for uninstalling dependencies); \
			$(call log-step,[Step 3/5] Uninstall $$PACKAGE package from the persistent storage (volume)); \
			$(call log-step,[Step 4/5] Update ${CONFIG_NPM} and ${CONFIG_PACKAGE}); \
			$(call log-step,[Step 5/5] Remove the container); \
			docker-compose run --rm ${SERVICE_APP} remove $$PACKAGE; \
			$(call helper-package,$$PACKAGE,uninstall); \
			$(txt-done); \
		else \
			echo "Skipped, you did not enter the package name, please try again."; \
		fi; \
	fi;

--------------------------------------------------------------------------------

# Upper


define upper
	ACTION=$(1); \
	printf "$$(tr '[:lower:]' '[:upper:]' <<< $${ACTION:0:1})$${ACTION:1}\n"
endef

.PHONY: yo
yo: ## Yo
	@$(call upper,install)

--------------------------------------------------------------------------------

# Extract version from package.json (NPM) using bash / shell

define helper-exist
	NAME=$(1); \
	if grep -q "\"$${NAME}\"" ${CONFIG_NPM}; then \
		VERSION=$$(cat ${CONFIG_NPM} \
			| grep $${NAME} \
			| head -1 \
			| awk -F: '{ print $$2 }' \
			| sed 's/[",]//g'); \
		echo $$VERSION; \
	else \
		echo "not exist"; \
	fi;
endef

.PHONY: yo
yo: ## Yo
	@$(call helper-exist,axios)

--------------------------------------------------------------------------------

# How to test if string exists in file with Bash?
# https://stackoverflow.com/questions/4749330/how-to-test-if-string-exists-in-file-with-bash

define helper-exist
	@read -p "Enter the input: " INPUT; \
	if [ "$$INPUT" != "" ]; then \
		if grep -Fxq "$$INPUT" ${HOST_DNS}; then \
			echo "found"; \
		else \
			echo "not found"; \
		fi; \
	else \
		echo "Skipping"; \
	fi;
endef

.PHONY: yo
yo: ## Yo
	@$(helper-exist)

--------------------------------------------------------------------------------

# Commit snippet

read -p "Would you like to commit the changes? " CONFIRMATION; \
case "$$CONFIRMATION" in \
	[yY] | [yY][eE][sS]) \
		$(newline); \
		$(call log-start,Preparing for the commit...); \
		git add ${CONFIG_NPM} ${CONFIG_PACKAGE}; \
		git status; \
		$(call log-start,Committing the changes...); \
		git commit -m "Install $(1) package"; \
		$(newline); \
		$(txt-result); \
		$(call log-sum,The commit log); \
		git log -1 --stat; \
		$(newline); \
		$(call log-sum,Summary); \
		printf "The package has been $(2) successfully.\n"; \
	;; \
	[nN] | [nN][oO] | *) \
		$(newline); \
		$(call log-sum,Summary); \
		printf "The package has been $(2) successfully$(,) please commit the changes.\n"; \
	;; \
esac; \

--------------------------------------------------------------------------------

# Case variables

CASE_ANY = [nN] | [nN][oO] | *)
CASE_NO  = [nN] | [nN][oO])
CASE_YES = [yY] | [yY][eE][sS])
.PHONY: yo
yo:
	@read -p "Yo? " CONFIRMATION; \
	case "$$CONFIRMATION" in \
		${CASE_YES} \
			echo "Yes"; \
		;; \
		${CASE_NO} \
			echo "No"; \
		;; \
		*) \
			echo "Enter"; \
		;; \
	esac

--------------------------------------------------------------------------------

.PHONY: dummy
dummy: ##Dummy
	@mkdir build coverage
	@cd build && touch 001.txt 002.txt 003.txt 004.txt 005.txt
	@cd coverage && touch 001.txt 002.txt 003.txt 004.txt 005.txt
	@cd tmp && touch 001.txt 002.txt 003.txt 004.txt 005.txt

--------------------------------------------------------------------------------

@$(newline)
@printf "$(txt-note): This is most commonly used when you have just checked out code for a project,\nor when another developer on the project has added a new dependency that you need to pick up.\n"
@$(newline)
--------------------------------------------------------------------------------

@$(newline)
@$(call headline,Configuration files)
@echo "Amazon Web Services (AWS)      : ${CONFIG_AWS}"
@echo "NPM & Yarn                     : ${CONFIG_NPM}"
@echo "Travis CI                      : ${CONFIG_CI}"
@echo "Environment variables          : ${CONFIG_ENV}"

@$(newline)
@$(call headline,Files & Directories)
@echo "Optimized production build     : ${DIR_BUILD}"
@echo "Code coverage                  : ${DIR_COVERAGE}"
@echo "Temporary                      : ${DIR_TEMP}"
@echo "Treemap                        : ${FILE_TREEMAP}"

docker image inspect "node:latest" > /dev/null 2>&1 || echo "does not exist!"

docker image inspect node:10.11.0-alpine >/dev/null 2>&1 && echo yes || echo no

--------------------------------------------------------------------------------

.PHONY: yo
yo:
	@if [ -d ${DIR_BACKUP} ]; then \
  	echo "exist"; \
	else \
		echo "not exist"; \
	fi

--------------------------------------------------------------------------------
# Check if Git working tree is dirty

https://remarkablemark.org/blog/2017/10/12/check-git-dirty/
https://stackoverflow.com/questions/3878624/how-do-i-programmatically-determine-if-there-are-uncommitted-changes

# How to check if a command succeeded?

https://askubuntu.com/questions/29370/how-to-check-if-a-command-succeeded

--------------------------------------------------------------------------------

.PHONY: rai
rai:
	@if [[ $$(git diff --stat) != "" ]]; then \
		echo "dirty"; \
	else \
		echo "clean"; \
	fi;

--------------------------------------------------------------------------------

.PHONY: rai
rai:
	@if [ "$(docker container ls | grep playground-local-proxy)" ]; then \
		echo "running"; \
	else \
		echo "not running."; \
	fi